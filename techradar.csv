name,ring,quadrant,isNew,description
Applying product management to internal platforms,Adopt,Data,FALSE,"<p>More and more companies are building internal platforms to roll out new digital solutions quickly and efficiently. Companies that succeed with this strategy are <strong>applying product management to internal platforms</strong>. This means establishing empathy with internal consumers (the development teams) and collaborating with them on the design. Platform product managers create roadmaps and ensure the platform delivers value to the business and enhances the developer experience. Unfortunately, we're also seeing less successful approaches, where teams create a platform in the void, based on unverified assumptions and without internal customers. These platforms, often despite aggressive internal tactics, end up being underutilized and a drain on the organization's delivery capability. As usual, good product management is all about building products that consumers love.</p>"
Simplest possible feature toggle,Adopt,Data,TRUE,"<p>Unfortunately, <a href=""https://martinfowler.com/articles/feature-toggles.html"">feature toggles</a> are less common than we'd like, and quite often we see people mixing up its types and use cases. It's quite common to come across teams that use heavyweight platforms such as <a href=""https://launchdarkly.com/"">LaunchDarkly</a> to implement feature toggles, including release toggles, to benefit from <a href=""https://martinfowler.com/articles/continuousIntegration.html"">Continuous Integration</a>, when all you need are if/else conditionals. Therefore, unless you need A/B testing or <a href=""https://martinfowler.com/bliki/CanaryRelease.html"">canary release</a> or hand over feature release responsibility to business folks, we encourage you to use the <strong>simplest possible feature toggle</strong> instead of unnecessarily complex feature toggle frameworks.</p>"
Continuous delivery for machine learning (CD4ML),Trial,Data,FALSE,"<p>Applying machine learning to make the business applications and services intelligent is more than just training models and serving them. It requires implementing end-to-end and continuously repeatable cycles of training, testing, deploying, monitoring and operating the models. <strong><a href=""https://martinfowler.com/articles/cd4ml.html"">Continuous delivery for machine learning (CD4ML)</a></strong> is a technique that enables reliable end-to-end cycles of development, deploying and monitoring machine learning models. The underpinning technology stack to enable CD4ML includes tooling for accessing and discovering data, version control of artefacts (such as data, model and code), continuous delivery pipelines, automated environment provisioning for various deployments and experiments, model performance assessment and tracking, and model operational observability. Companies can choose their own tool set depending on their existing tech stack. CD4ML emphasizes automation and removing manual handoffs. CD4ML is our de facto approach for developing ML models.</p>"
Ethical bias testing,Trial,Data,FALSE,"<p>Over the past year, we've seen a shift in interest around machine learning and deep neural networks in particular. Until now, tool and technique development has been driven by excitement over the remarkable capabilities of these models. Currently, though, there is rising concern that these models could cause unintentional harm. For example, a model could be trained inadvertently to make profitable credit decisions by simply excluding disadvantaged applicants. Fortunately, we're seeing a growing interest in <strong>ethical bias testing</strong> that will help to uncover potentially harmful decisions. Tools such as <a href=""https://github.com/marcotcr/lime"">lime</a>, <a href=""https://aif360.mybluemix.net/"">AI Fairness 360</a> or <a href=""/radar/tools/what-if-tool"">What-If Tool</a> can help uncover inaccuracies that result from underrepresented groups in training data and visualization tools such as <a href=""https://ai.googleblog.com/2017/07/facets-open-source-visualization-tool.html"">Google Facets</a> or <a href=""https://pair-code.github.io/facets/"">Facets Dive</a> can be used to discover subgroups within a corpus of training data. We've used lime (local interpretable model-agnostic explanations) in addition to this technique in order to understand the predictions of any machine-learning classifier and what classifiers (or models) are doing.</p>"
Zero trust architecture (ZTA),Trial,Data,TRUE,"<p>The technology landscape of organizations today is increasingly more complex with assets — data, functions, infrastructure and users — spread across security boundaries, such as local hosts, multiple cloud providers and a variety of SaaS vendors. This demands a paradigm shift in enterprise security planning and systems architecture, moving from static and slow-changing security policy management, based on trust zones and network configurations, to dynamic, fine-grained security policy enforcement based on temporal access privileges.</p>

<p><strong>Zero trust architecture (ZTA)</strong> is an organization's strategy and journey to implement zero-trust security principles for all of their assets — such as devices, infrastructure, services, data and users — and includes implementing practices such as securing all access and communications regardless of the network location, enforcing policies as code based on the least privilege and as granular as possible, and continuous monitoring and automated mitigation of threats. Our Radar reflects many of the enabling techniques such as <a href=""/radar/techniques/security-policy-as-code"">security policy as code</a>, <a href=""/radar/techniques/sidecars-for-endpoint-security"">sidecars for endpoint security</a> and <a href=""/radar/techniques/beyondcorp"">BeyondCorp</a>. If you're on your journey toward ZTA, refer to the <a href=""https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-207-draft2.pdf"">NIST ZTA publication</a> to learn more about principles, enabling technology components and migration patterns as well as Google's publication on <a href=""https://cloud.google.com/security/beyondprod"">BeyondProd</a>.</p>"
Data mesh,Assess,Data,FALSE,"<p><strong><a href=""https://martinfowler.com/articles/data-monolith-to-mesh.html"">Data mesh</a></strong> is an architectural and organizational paradigm that challenges the age-old assumption that we must centralize big analytical data to use it, have data all in one place or be managed by a centralized data team to deliver value. Data mesh claims that for big data to fuel innovation, its ownership must be federated among domain data owners who are accountable for providing their data as products (with the support of a self-serve data platform to abstract the technical complexity involved in serving data products);  it must also adopt a new form of federated governance through automation to enable interoperability of domain-oriented data products. Decentralization, along with interoperability and focus on the experience of data consumers, are key to the democratization of innovation using data.</p>

<p>If your organization has a large number of domains with numerous systems and teams generating data or a diverse set of data-driven use cases and access patterns, we suggest you assess data mesh. Implementation of data mesh requires investment in building a self-serve data platform and embracing an organizational change for domains to take on the long-term ownership of their data products, as well as an incentive structure that rewards domains serving and utilizing data as a product.</p>"
Preflight builds,Assess,Data,TRUE,"<p>Even though we strongly advocate in favor of CI rather than <a href=""/radar/techniques/gitflow"">Gitflow</a>, we know that <a href=""https://trunkbaseddevelopment.com/committing-straight-to-the-trunk/"">committing straight to the trunk</a> and running the CI on a master branch can be ineffective if the team is too big, the builds are slow or flaky, or the team lacks the discipline to run the full test suite locally. In this situation a red build can block multiple devs or pairs of devs. Instead of fixing the underlying root cause — slow builds, the inability to run tests locally or monolithic architectures that necessitate many people working in the same area — teams usually rely on feature branches to bypass these issues. We discourage feature branches, given they may require significant effort to resolve merge conflicts, and they introduce longer feedback loops and potential bugs during conflict resolution. Instead, we propose using <strong>preflight builds</strong> as an alternative: these are pull request–based builds for “micro branches” that live only for the duration of the pipeline run, with the branch opened for every commit. To help automate this workflow, we've come across bots such as <a href=""https://bors.tech/"">Bors</a>, which automates merging to master and branch deletion in case the mini branch build succeeds. We're assessing this flow, and you should too; but don't use this to solve the wrong problem, as it can lead to misuse of branches and may cause more harm than benefit.</p>"
Long-lived branches with Gitflow,Hold,Data,FALSE,"<p>Five years ago we highlighted the problems with <strong>long-lived branches with Gitflow</strong>. Essentially, long-lived branches are the opposite of continuously integrating all changes to the source code, and in our experience continuous integration is the better approach for most kinds of software development. Later we extended our caution to <a href=""/radar/techniques/gitflow"">Gitflow</a> itself, because we saw teams using it almost exclusively with long-lived branches. Today, we still see teams in settings where continuous delivery of web-based systems is the stated goal being drawn to long-lived branches. So we were delighted that the author of Gitflow has now added a note to his <a href=""https://nvie.com/posts/a-successful-git-branching-model/"">original article</a>, explaining that Gitflow was not intended for such use cases.</p>"
Snapshot testing only,Hold,Data,TRUE,"<p>The value of snapshot testing is undeniable when working with legacy systems by ensuring that the system continues to work and the legacy code doesn't break. However, we're seeing the common, rather harmful practice of using <strong>snapshot testing only</strong> as the primary test mechanism. Snapshot tests validate the exact result generated in the DOM by a component, not the component's behavior; therefore, it can be weak and unreliable, fostering the ""only delete the snapshot and regenerate it"" bad practice. Instead, you should test the logic and behavior of the components emulating what users would do. This mindset is encouraged by tools in the <a href=""https://testing-library.com/docs/guiding-principles"">Testing Library</a> family.</p>"
.NET Core,Adopt,User Experience,FALSE,"<p>We previously had <strong>.NET Core</strong> in Adopt, indicating that it had become our default for .NET projects. But we felt it's worth again calling attention to .NET Core. With the release of .NET Core 3.<em>x</em> last year, the bulk of the features from .NET Framework have now been ported into .NET Core. With the announcement that <a href=""https://devblogs.microsoft.com/dotnet/introducing-net-5"">.NET Framework is on its last release</a>, Microsoft have reinforced the view that <a href=""https://devblogs.microsoft.com/dotnet/net-core-is-the-future-of-net/"">.NET Core is the future of .NET</a>. Microsoft has done a lot of work to make .NET Core <a href=""https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2019-update/"">container friendly</a>. Most of our .NET Core–based projects target Linux and are often deployed as containers. The upcoming <a href=""https://devblogs.microsoft.com/dotnet/introducing-net-5/"">.NET 5</a> release looks promising, and we're looking forward to it.</p>"
Istio,Adopt,User Experience,FALSE,"<p>If you're building and operating a scaled <a href=""https://martinfowler.com/articles/microservices.html"">microservices</a> architecture and have embraced <a href=""/radar/platforms/kubernetes"">Kubernetes</a>, adopting <a href=""/radar/techniques/service-mesh"">service mesh</a> to manage all cross-cutting aspects of running the architecture is a default position. Among various implementations of service mesh, <strong><a href=""https://istio.io"">Istio</a></strong> has gained majority adoption. It has a rich feature set, including service discovery, traffic management, service-to-service and origin-to-service security, observability (including telemetry and distributed tracing), rolling releases and resiliency. Its user experience has been improved in its latest releases, because of its ease of installation and control panel architecture. Istio has lowered the bar for implementing large-scale microservices with operational quality for many of our clients, while admitting that operating your own Istio and Kubernetes instances requires adequate knowledge and internal resources which is not for the fainthearted.</p>"
Hydra,Trial,User Experience,FALSE,"<p>Not everyone needs a self-hosted OAuth2 solution, but if you do, have a look at <strong><a href=""https://www.ory.sh/hydra/"">Hydra</a></strong> — a fully compliant open source OAuth2 server and OpenID connect provider. Hydra has in-memory storage support for development and a relational database (PostgreSQL) for production use cases. Hydra as such is stateless and easy to scale horizontally in platforms such as <a href=""/radar/platforms/kubernetes"">Kubernetes</a>. Depending on your performance requirement, you may have to tune the number of database instances while scaling Hydra instances. And because Hydra doesn't provide any identity management solutions out of the box, you can integrate whatever flavor of identity management you have with Hydra through a clean API. This clear separation of identity from the rest of the OAuth2 framework makes it easier to integrate Hydra with an existing authentication ecosystem.</p>"
OpenTelemetry,Trial,User Experience,FALSE,"<p><strong><a href=""https://opentelemetry.io/"">OpenTelemetry</a></strong> is an open source observability project that merges <a href=""https://opentracing.io/"">OpenTracing</a> and <a href=""https://github.com/census-instrumentation"">OpenCensus</a>. The OpenTelemetry project includes <a href=""https://github.com/open-telemetry/opentelemetry-specification"">specification</a>, libraries, agents, and other components needed to capture telemetry from services to better observe, manage and debug them. It covers the three pillars of observability — distributed tracing, metrics and logging (currently in beta) — and its specification connects these three pieces through <a href=""https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/correlationcontext/api.md"">correlations</a>; thus you can use <em>metrics</em> to pinpoint a problem, locate the corresponding <em>traces</em> to discover where the problem occured, and ultimately study the corresponding <em>logs</em> to find the exact root cause. OpenTelemetry components can be connected to back-end observability systems such as <a href=""/radar/tools/prometheus"">Prometheus</a> and <a href=""/radar/tools/jaeger"">Jaeger</a> among <a href=""https://opentelemetry.io/registry/?s=exporter"">others</a>. Formation of OpenTracing is a positive step toward the convergence of standardization and the simplification of tooling.</p>"
Snowflake,Trial,User Experience,FALSE,"<p><strong><a href=""https://www.snowflake.com"">Snowflake</a></strong> has proven to be a robust SaaS big data storage, warehouse or lake solution for many of our clients. It has a superior architecture to scale storage, compute, and services to load, unload and use data. It's also very flexible: it supports storage of structured, semi-structured and unstructured data; provides a growing list of <a href=""https://docs.snowflake.com/en/user-guide/conns-drivers.html"">connectors</a> for different access patterns such as Spark for data science and SQL for analytics; and runs on multiple cloud providers. Our advice to many of our clients is to use managed services for their utility technology such as big data storage; however, if the risk and regulations prohibit the use of managed services, then Snowflake is a good candidate for companies with large volumes of data and heavy processing workloads. Although we've been successful using Snowflake in our medium-sized engagements, we've yet to experience Snowflake in large ecosystems where data need to be owned across segments of the organization.</p>"
Matomo,Assess,User Experience,TRUE,"<p><strong><a href=""https://matomo.org"">Matomo</a></strong> (formerly Piwik) is an open source web analytics platform that provides you with full control over your data. You can self-host Matomo and secure your web analytics data from third parties. Matomo also makes it easy to integrate web analytics data with your in-house data platform and lets you build usage models that are tailored to your needs.</p>"
MeiliSearch,Assess,User Experience,TRUE,"<p><strong><a href=""https://github.com/meilisearch/MeiliSearch"">MeiliSearch</a></strong> is a fast, easy-to-use and easy-to-deploy text search engine. Over the years Elasticsearch has become the popular choice for scalable text searches. However, if you don't have the volume of data that warrants a distributed solution but still want to provide a fast typo-tolerant search engine, then we recommend assessing MeiliSearch.</p>"
Stratos,Assess,User Experience,TRUE,"<p>Ultraleap (previously Leap Motion) has been a leader in the XR space for some time, creating remarkable hand-tracking hardware that allows a user's hands to make the leap into virtual reality. <strong><a href=""https://www.ultraleap.com/haptics/"">Stratos</a></strong> is Ultraleap's underlying haptics, sensors and software platform, and it can use targeted ultrasound to create haptic feedback in mid-air. A use case is responding to a driver's hand gesture to change the air conditioning in the car and providing haptic feedback as part of the interface. We're excited to see this technology and what creative technologists might do to incorporate it into their use cases.</p>"
Trillian,Assess,User Experience,TRUE,"<p><strong><a href=""https://github.com/google/trillian"">Trillian</a></strong> is a cryptographically verifiable, centralized data store. For trustless, decentralized environments, you can use blockchain-based distributed ledgers. For enterprise environments, however, where the cost of CPU-heavy consensus protocols is unwarranted, we recommend you give Trillian a try.</p>"
Node overload,Hold,User Experience,TRUE,"<p>Technologies, especially wildly popular ones, have a tendency to be overused. What we're seeing at the moment is <strong>Node overload</strong>, a tendency to use Node.js indiscriminately or for the wrong reasons. Among these, two stand out in our opinion. Firstly, we frequently hear that Node should be used so that all programming can be done in one programming language. Our view remains that <a href=""/radar/techniques/polyglot-programming"">polyglot programming</a> is a better approach, and this still goes <a href=""/radar/languages-and-frameworks/javascript-as-a-first-class-language"">both ways</a>. Secondly, we often hear teams cite performance as a reason to choose Node.js. Although there are myriads of more or less sensible benchmarks, this perception is rooted in history. When Node.js became popular, it was the first major framework to embrace a nonblocking programming model which made it very efficient for IO-heavy tasks. (We mentioned this in our write-up of Node.js in 2012.) Due to its single-threaded nature, Node.js was never a good choice for compute-heavy workloads, though, and now that capable nonblocking frameworks also exist on other platforms — some with elegant, modern APIs — performance is no longer a reason to choose Node.js.</p>"
Cypress,Adopt,Tools,FALSE,"<p><strong><a href=""http://www.cypress.io/"">Cypress</a></strong> is still a favorite among our teams where developers manage end-to-end tests themselves, as part of a healthy <a href=""https://martinfowler.com/articles/practical-test-pyramid.html#End-to-endTests"">test pyramid</a>, of course. We decided to call it out again in this Radar because recent versions of Cypress have added <a href=""https://cypress.io/blog/2020/02/06/introducing-firefox-and-edge-support-in-cypress-4-0/"">support for Firefox</a>, and we strongly suggest testing on multiple browsers. The dominance of Chrome and Chromium-based browsers has led to a worrying trend of teams seemingly only testing with Chrome which can lead to <a href=""https://twitter.com/mike_conley/status/1245797292453609478"">nasty surprises</a>.</p>"
Figma,Adopt,Tools,FALSE,"<p><strong><a href=""https://www.figma.com/"">Figma</a></strong> has demonstrated to be the go-to tool for collaborative design, not only for designers but for multidisciplinary teams too; it allows developers and other roles to view and comment on designs through the browser without the desktop version. Compared to its competitors (e.g., Invision or Sketch) which have you use more than one tool for versioning, collaborating and design sharing, Figma puts together all of these features in one tool that makes it easier for our teams to discover new ideas together. Our teams find Figma very useful, especially in remote and distributed design work enablement and facilitation. In addition to its real-time design and collaboration capabilities, Figma also offers an API that helps to improve the <a href=""/radar/techniques/designops"">DesignOps</a> process.</p>"
Dojo,Trial,Tools,TRUE,"<p>A few years ago, Docker — and containers in general — radically changed how we think about packaging, deploying and running our applications. But despite this improvement in production, developers still spend a lot of time setting up development environments and regularly run into ""but it works on my machine"" style problems. <strong><a href=""https://github.com/kudulab/dojo"">Dojo</a></strong> aims to fix this by creating standard development environments, versioned and released as Docker images. Several of our teams use Dojo to streamline developing, testing and building code from local development through production pipelines.</p>"
DVC,Trial,Tools,TRUE,"<p>In 2018 we mentioned <strong><a href=""https://dvc.org/"">DVC</a></strong> in conjunction with the <a href=""/radar/techniques/versioning-data-for-reproducible-analytics"">versioning data for reproducible analytics</a>. Since then it has become a favorite tool for managing experiments in machine learning (ML) projects. Since it's based on Git, DVC is a familiar environment for software developers to bring their engineering practices to ML practice. Because it versions the code that processes data along with the data itself and tracks stages in a pipeline, it helps bring order to the modeling activities without interrupting the analysts’ flow.</p>"
Experiment tracking tools for machine learning,Trial,Tools,FALSE,"<p>The day-to-day work of machine learning often boils down to a series of experiments in selecting a modeling approach and the network topology, training data and optimizing or tweaking the model. Data scientists must use experience and intuition to hypothesize changes and then measure the impact those changes have on the overall performance of the model. As this practice has matured, our teams have found an increasing need for <strong>experiment tracking tools for machine learning</strong>. These tools help investigators keep track of the experiments and work through them methodically. Although no clear winner has emerged, tools such as <a href=""https://mlflow.org/"">MLflow</a> and platforms such as <a href=""https://comet.ml"">Comet</a> or <a href=""https://neptune.ml"">Neptune</a> have introduced rigor and repeatability into the entire machine learning workflow.</p>"
Goss,Trial,Tools,TRUE,"<p>We mentioned <strong><a href=""https://github.com/aelsabbahy/goss"">Goss</a></strong>, a tool for <a href=""/radar/techniques/provisioning-testing"">provisioning testing</a>, in passing in previous Radars, for example, when describing the technique of <a href=""/radar/techniques/tdd-ing-containers"">TDD'ing containers</a>. Although Goss isn't always an alternative to <a href=""/radar/tools/serverspec"">Serverspec</a>, simply because it doesn't offer the same amount of features, you may want to consider it when its features meet your needs, especially since it comes as a small, self-contained binary (rather than requiring a Ruby environment). A common anti-pattern with using tools such as Goss is double-entry bookkeeping, where each change in the actual infrastructure as code files requires a corresponding change in the test assertions. Such tests are maintenance heavy and because of the close correspondence between code and test, failures mostly occur when an engineer updates one side and forgets the other. And these tests rarely catch genuine problems.</p>"
Jaeger,Trial,Tools,FALSE,"<p><strong><a href=""https://github.com/jaegertracing/jaeger"">Jaeger</a></strong> is an open source distributed tracing system. Similar to <a href=""/radar/tools/zipkin"">Zipkin</a>, it's been inspired by the Google <a href=""https://ai.google/research/pubs/pub36356"">Dapper</a> paper and complies with <a href=""/radar/platforms/opentelemetry"">OpenTelemetry</a>. We've used Jaeger successfully with <a href=""/radar/platforms/istio"">Istio</a> and <a href=""https://www.envoyproxy.io/"">Envoy</a> on Kubernetes and like its <a href=""https://github.com/jaegertracing/jaeger-ui"">UI</a>. Jaeger exposes tracing metrics in the <a href=""/radar/tools/prometheus"">Prometheus</a> format so they can be made available to other tools. However, a new generation of tools such as <a href=""/radar/tools/honeycomb"">Honeycomb</a> integrates traces and metrics into a single observability stream for simpler aggregate analysis. Jaeger joined <a href=""https://www.cncf.io/blog/2017/09/13/cncf-hosts-jaeger/"">CNCF</a> in 2017 and has recently been elevated to CNCF's highest level of maturity, indicating its widespread deployment into production systems.</p>"
k9s,Trial,Tools,TRUE,"<p>We continue to be ardent supporters of <a href=""/radar/techniques/infrastructure-as-code"">infrastructure as code</a>, and we continue to believe that a robust monitoring solution is a prerequisite for operating distributed applications. Sometimes an interactive tool such as the AWS web console can be a useful addition. It allows us to explore all kinds of resources in an ad-hoc fashion without having to remember every single obscure command. Using an interactive tool to make manual modifications on the fly is still a questionable practice, though. For <a href=""/radar/platforms/kubernetes"">Kubernetes</a> we now have <strong><a href=""https://k9scli.io/"">k9s</a></strong>, which provides an interactive interface for basically everything that kubectl can do. And to boot, it's not a web application but runs inside a terminal window, evoking fond memories of <a href=""https://en.wikipedia.org/wiki/Midnight_Commander"">Midnight Commander</a> for some of us.</p>"
kind,Trial,Tools,TRUE,"<p><strong><a href=""https://github.com/kubernetes-sigs/kind"">kind</a></strong> is a tool for running local <a href=""/radar/platforms/kubernetes"">Kubernetes</a> clusters using Docker container nodes. With <a href=""https://github.com/kubernetes/test-infra/tree/master/kubetest"">kubetest</a> integration, kind makes it easy to do end-to-end testing on Kubernetes. We've used kind to create ephemeral Kubernetes clusters to test Kubernetes resources such as Operators and Custom Resource Definitions (CRDs) in our CI pipelines.</p>"
mkcert,Trial,Tools,TRUE,"<p><strong><a href=""https://github.com/FiloSottile/mkcert"">mkcert</a></strong> is a convenient tool for creating locally trusted development certificates. Using certificates from real certificate authorities (CAs) for local development can be challenging if not impossible (for hosts such as example.test, localhost or 127.0.0.1). In such situations self-signed certificates may be your only option. mkcert lets you generate self-signed certificates and installs the local CA in the system root store. For anything other than local development and testing, we strongly recommend using certificates from real CAs to avoid trust issues.</p>"
MURAL,Trial,Tools,TRUE,"<p><strong><a href=""https://www.mural.co/"">MURAL</a></strong> describes itself as a ""digital workspace for visual collaboration"" and allows teams to interact with a shared workspace based on a whiteboard/sticky notes metaphor. Its features include voting, commenting, notes and ""follow the presenter."" We particularly like the template feature that allows a facilitator to design and then reuse guided sessions with a team. Each of the major collaboration suites have a tool in this space (for example, <a href=""https://jamboard.google.com/"">Google Jamboard</a> and <a href=""https://www.microsoft.com/en-ca/microsoft-365/microsoft-whiteboard/digital-whiteboard-app"">Microsoft Whiteboard</a>) and these are worth investigating, but we've found MURAL to be slick, effective and flexible.</p>"
Open Policy Agent (OPA),Trial,Tools,FALSE,"<p><strong><a href=""https://www.openpolicyagent.org/"">Open Policy Agent (OPA)</a></strong> has rapidly become a favorable component of many distributed cloud-native solutions that we build for our clients. OPA provides a uniform framework and <a href=""https://www.openpolicyagent.org/docs/latest/#rego"">language</a> for declaring, enforcing and controlling policies for various components of a cloud-native solution. It's a great example of a tool that implements <a href=""/radar/techniques/security-policy-as-code"">security policy as code</a>. We've had a smooth experience using OPA in multiple scenarios, including deploying resources to K8s clusters, enforcing access control across services in a <a href=""/radar/techniques/service-mesh"">service mesh</a> and fine-grained security controls as code for accessing application resources. A recent commercial offering, <a href=""https://www.styra.com/"">Styra's Declarative Authorization Service (DAS)</a>, eases the adoption of OPA for enterprises by adding a management tool, or control plane, to OPA for K8s with a prebuilt policy library, impact analysis of the policies and logging capabilities. We look forward to maturity and extension of OPA beyond operational services to (big) data-centric solutions.</p>"
Optimal Workshop,Trial,Tools,FALSE,"<p>UX research demands data collection and analysis to make better decisions about the products we need to build. Our teams find <strong><a href=""https://www.optimalworkshop.com"">Optimal Workshop</a></strong> useful because it makes it easy to validate prototypes and configure tests for data collection and thus make better decisions. Features such as first-click, card sorting, or a heatmap of user interaction help to both validate prototypes and improve website navigation and information display. It's an ideal tool for distributed teams since it allows them to conduct remote research.</p>"
Phrase,Trial,Tools,TRUE,"<p>As mentioned in our description of <a href=""/radar/platforms/crowdin"">Crowdin</a>, you now have a choice of platforms to manage the translation of a product into multiple languages instead of emailing large spreadsheets. Our teams report positive experiences with <strong><a href=""https://phrase.com/"">Phrase</a></strong>, emphasizing that it's easy to use for all key user groups. Translators use a convenient browser-based UI. Managers can add new fields and synchronize translations with other teams in the same UI. Developers can access Phrase locally and from a build pipeline. A feature that deserves a specific mention is the ability to apply versioning to translations through tags, which makes it possible to compare the look of different translations inside the actual product.</p>"
ScoutSuite,Trial,Tools,FALSE,"<p><strong><a href=""https://github.com/nccgroup/ScoutSuite"">ScoutSuite</a></strong> is an expanded and updated tool based on Scout2 (featured in the Radar in 2018) that provides security posture assessment across <a href=""/radar/platforms/aws"">AWS</a>, <a href=""/radar/platforms/azure"">Azure</a>, <a href=""/radar/platforms/google-cloud-platform"">GCP</a> and other cloud providers. It works by automatically aggregating configuration data for an environment and applying rules to audit the environment. We've found this very useful across projects for doing point-in-time security assessments.</p>"
Visual regression testing tools,Trial,Tools,FALSE,"<p>Since we first mentioned <strong>visual regression testing tools</strong> in 2014, the use of the technique has spread and the tools landscape has evolved. <a href=""/radar/tools/backstopjs"">BackstopJS</a> remains an excellent choice with new features being added regularly, including support for running inside Docker containers. <a href=""/radar/tools/loki"">Loki</a> was featured in our previous Radar. <a href=""https://applitools.com/"">Applitools</a>, <a href=""https://crossbrowsertesting.com/"">CrossBrowserTesting</a> and <a href=""https://percy.io/"">Percy</a> are SaaS solutions. Another notable mention is <a href=""https://github.com/rsmbl"">Resemble.js</a>, an image diffing library. Although most teams use it indirectly as part of BackstopJS, some of our teams have been using it to analyze and compare images of web pages directly. In general, our experience shows that visual regression tools are less useful in the early stages when the interface goes through significant changes, but they certainly prove their worth as the product matures and the interface stabilizes.</p>"
Visual Studio Live Share,Trial,Tools,FALSE,"<p><strong><a href=""https://marketplace.visualstudio.com/items?itemName=MS-vsliveshare.vsliveshare-pack"">Visual Studio Live Share</a></strong> is a suite of extensions for <a href=""/radar/tools/visual-studio-code"">Visual Studio Code</a> and Visual Studio. At a time when teams are searching for good remote collaboration options, we want to call attention to the excellent tooling here. Live Share provides a good, low-latency remote-pairing experience, and requires significantly less bandwidth than the brute-force approach of sharing your entire desktop. Importantly, developers can work with their preferred configuration, extensions and key mappings during a pairing session. In addition to real-time collaboration for editing and debugging code, Live Share allows voice calls and sharing terminals and servers.</p>"
Apache Superset,Assess,Tools,TRUE,"<p><strong><a href=""https://superset.apache.org/"">Apache Superset</a></strong> is a great business intelligence (BI) tool for data exploration and visualization to work with large data lake and data warehouse setups. It works, for example, with <a href=""/radar/platforms/presto"">Presto</a>, <a href=""https://aws.amazon.com/athena/"">Amazon Athena</a> and <a href=""https://aws.amazon.com/redshift/"">Amazon Redshift</a> and can be nicely integrated with enterprise authentication. Moreover, you don't have to be a data engineer to use it; it’s meant to benefit all engineers exploring data in their everyday work. It's worth pointing out that Apache Superset is currently undergoing incubation at the Apache Software Foundation (ASF), meaning it's not yet fully endorsed by ASF.</p>"
AsyncAPI,Assess,Tools,TRUE,"<p>Open standards are one of the foundational pillars of building distributed systems. For example, the <a href=""https://github.com/OAI"">OpenAPI (formerly Swagger)</a> specification, as an industry standard to define RESTful APIs, has been instrumental to the success of distributed architectures such as <a href=""https://martinfowler.com/articles/microservices.html"">microservices</a>. It has enabled a proliferation of tooling to support building, testing and monitoring RESTful APIs. However, such standardizations have been largely missing in distributed systems for <a href=""https://martinfowler.com/articles/201701-event-driven.html"">event-driven APIs</a>.</p>

<p><strong><a href=""https://www.asyncapi.com/"">AsyncAPI</a></strong> is an open source initiative to create a much needed event-driven and asynchronous API standardization and development tooling. The <a href=""https://www.asyncapi.com/docs/specifications/2.0.0/"">AsyncAPI specification</a>, inspired by the OpenAPI specification, describes and documents event-driven APIs in a machine-readable format. It's protocol agnostic, so it can be used for APIs that work over many protocols, including MQTT, WebSockets, and Kafka. We're eager to see the ongoing improvements of AsyncAPI and further maturity of its tooling ecosystem.</p>"
ConfigCat,Assess,Tools,TRUE,"<p>If you're looking for a service to support dynamic feature toggles (and bear in mind that simple feature toggles work well too), check out <strong><a href=""https://configcat.com/"">ConfigCat</a></strong>. We'd describe it as ""like LaunchDarkly but cheaper and a bit less fancy"" and find that it does most of what we need. ConfigCat supports simple feature toggles, user segmentation, and A/B testing and has a generous free tier for low-volume use cases or those just starting out.</p>"
Gitpod,Assess,Tools,TRUE,"<p>You can build most software following a simple two-step process: check out a repository, and then run a single build script. The process of setting up a full coding environment can still be cumbersome, though. <strong><a href=""https://www.gitpod.io/"">Gitpod</a></strong> addresses this by providing cloud-based, ""ready-to-code"" environments for Github or GitLab repositories. It offers an IDE based on Visual Studio Code that runs inside the web browser. By default, these environments are launched on the Google Cloud Platform, although you can also deploy on-premise solutions. We see the immediate appeal, especially for open source software where this approach can lower the bar for casual contributors. However, it remains to be seen how viable this approach will be in corporate environments.</p>"
Gloo,Assess,Tools,TRUE,"<p>With the increasing adoption of <a href=""/radar/platforms/kubernetes"">Kubernetes</a> and <a href=""/radar/techniques/service-mesh"">service mesh</a>, API gateways have been experiencing an existential crisis in cloud-native distributed systems. After all, many of their capabilities (such as traffic control, security, routing and observability) are now provided by the cluster’s ingress controller and mesh gateway. <strong><a href=""https://www.solo.io/products/gloo/"">Gloo</a></strong> is a lightweight API gateway that embraces this change; it uses <a href=""https://www.envoyproxy.io/"">Envoy</a> as its gateway technology, while providing added value such as a cohesive view of the APIs to the external users and applications. It also provides an administrative interface for controlling Envoy gateways and runs and integrates with multiple service mesh implementations such as <a href=""https://linkerd.io/"">Linkerd</a>, <a href=""/radar/platforms/istio"">Istio</a> and <a href=""https://aws.amazon.com/app-mesh/"">AWS App Mesh</a>. While its open source implementation provides the basic capabilities expected from an API gateway, its enterprise edition has a more mature set of security controls such as API key management or integration with <a href=""/radar/tools/open-policy-agent-opa"">OPA</a>. Gloo is a promising lightweight API gateway that plays well with the ecosystem of cloud-native technology and architecture, while avoiding the API gateway trap of enabling business logic to glue APIs for the end user.</p>"
Lens,Assess,Tools,TRUE,"<p>One of the strengths of <a href=""/radar/platforms/kubernetes"">Kubernetes</a> is its flexibility and range of configuration possibilities along with the API-driven, programmable configuration mechanisms and command-line visibility and control using manifest files. However, that strength can also be a weakness: when deployments are complex or when managing multiple clusters, it can be difficult to get a clear picture of the overall status through command-line arguments and manifests alone. <strong><a href=""https://k8slens.dev/"">Lens</a></strong> attempts to solve this problem with an integrated environment for viewing the current state of the cluster and its workloads, visualizing cluster metrics and changing configurations through an embedded text editor. Rather than a simple point-and-click interface, Lens brings together the tools an administrator would run from the command line into a single, navigable interface. This tool is one of several approaches that are trying to tame the complexity of Kubernetes management. We've yet to see a clear winner in this space, but Lens strikes an interesting balance between a graphical UI and command-line–only tools.</p>"
Manifold,Assess,Tools,TRUE,"<p><strong><a href=""https://github.com/uber/manifold"">Manifold</a></strong> is a model-agnostic visual debugger for machine learning (ML). Model developers spend a significant amount of time on iterating and improving an existing model rather than creating a new one. By shifting the focus from model space to data space, Manifold supplements the existing performance metrics with a visual characteristics of the data set that influences the model performance. We think Manifold will be a useful tool to assess in the ML ecosystem.</p>"
Sizzy,Assess,Tools,TRUE,"<p>Building web applications that look just as intended on a large number of devices and screen sizes can be cumbersome. <strong><a href=""https://sizzy.co/"">Sizzy</a></strong> is a SaaS solution that shows many viewports in a single browser window. The application is rendered in all viewports simultaneously and interactions with the application are also synched across the viewports. In our experience interacting with an application in this way can make it easier to spot potential issues earlier, before a <a href=""/radar/tools/visual-regression-testing-tools"">visual regression testing tool</a> flags the issue in the build pipeline. We should mention, though, that some of our developers who tried Sizzy for a while did, on balance, prefer to work with the tooling provided by Chrome.</p>"
Snowpack,Assess,Tools,TRUE,"<p><strong><a href=""https://www.snowpack.dev/"">Snowpack</a></strong> is an interesting new entrant in the field of JavaScript build tools. The key improvement over other solutions is that Snowpack makes it possible to build applications with modern frameworks such as <a href=""/radar/languages-and-frameworks/react-js"">React.js</a>, <a href=""/radar/languages-and-frameworks/vue-js"">Vue.js</a>, and <a href=""/radar/languages-and-frameworks/angular"">Angular</a> without the need for a bundler. Cutting out the bundling step dramatically improves the feedback cycle during development because changes become available in the browser almost immediately. For this magic to work, Snowpack transforms the dependencies in <code>node_modules</code> into single JavaScript files in a new <code>web_modules</code> directory, from where they can be imported as an ECMAScript module (ESM). For IE11 and other browsers that don't support ESM, a workaround is available. Unfortunately, because no browser today can import CSS from JavaScript, using CSS modules is <a href=""https://www.snowpack.dev/#importing-css"">not straightforward</a>.</p>"
tfsec,Assess,Tools,TRUE,"<p>Security is everyone's concern and capturing risks early is always better than facing problems later on. In the <a href=""/radar/techniques/infrastructure-as-code"">infrastructure as code</a> space, where <a href=""/radar/tools/terraform"">Terraform</a> is an obvious choice to manage cloud environments, we now also have <strong><a href=""https://github.com/liamg/tfsec"">tfsec</a></strong>, which is a static analysis tool that helps to scan Terraform templates and find any potential security issues. It comes with preset rules for different cloud providers including <a href=""/radar/platforms/aws"">AWS</a> and <a href=""/radar/platforms/azure"">Azure</a>. We always like tools that help to mitigate security risks, and tfsec not only excels in identifying security risks, it's also easy to install and use.</p>"
React Hooks,Adopt,languages & Tools,FALSE,"<p><strong><a href=""https://reactjs.org/docs/hooks-intro.html"">React Hooks</a></strong> have introduced a new approach to managing stateful logic; given React components have always been closer to functions than classes, Hooks have embraced this and brought state to the functions, instead of taking function as methods to the state with classes. Based on our experience, Hooks improve reuse of functionality among components and code readability. Given Hooks’ testability improvements, using <a href=""https://reactjs.org/docs/test-renderer.html"">React Test Renderer</a> and <a href=""/radar/languages-and-frameworks/react-testing-library"">React Testing Library</a>, and their growing community support, we consider them our approach of choice.</p>"
React Testing Library,Adopt,languages-and-frameworks,FALSE,"<p>The JavaScript world moves pretty fast, and as we gain more experience using a framework our recommendations change. The <strong><a href=""https://testing-library.com/"">React Testing Library</a></strong> is a good example of a framework that with deeper usage has eclipsed the alternatives to become the sensible default when testing React-based frontends. Our teams like the fact that tests written with this framework are less brittle than with alternative frameworks such as <a href=""/radar/languages-and-frameworks/enzyme"">Enzyme</a>, because you're encouraged to test component relationships individually as opposed to testing all implementation details. This mindset is brought by <a href=""https://testing-library.com/"">Testing Library</a> which React Testing Library is part of and which provides a whole family of libraries for <a href=""/radar/languages-and-frameworks/angular"">Angular</a> and <a href=""/radar/languages-and-frameworks/vue-js"">Vue.js</a>, for example.</p>"
Vue.js,Adopt,languages-and-frameworks,FALSE,"<p><strong><a href=""https://vuejs.org/"">Vue.js</a></strong> has become one of the successfully applied, loved and trusted frontend JavaScript frameworks among our community. Although there are other, well-adopted alternatives, such as <a href=""/radar/languages-and-frameworks/react-js"">React.js</a>, the simplicity of Vue.js in API design, its clear segregation of directives and components (one file per component idiom) and its simpler state management have made it a compelling option among others.</p>"
CSS-in-JS,Trial,languages-and-frameworks,FALSE,"<p>Since we first mentioned <strong>CSS-in-JS</strong> as an emerging technique in 2017, it has become much more popular, a trend we also see in our work. With some solid production experience under our belts, we can now recommend CSS-in-JS as a technique to trial. A good starting point is the <a href=""/radar/languages-and-frameworks/styled-components"">styled components</a> framework, which we mentioned in our previous Radar. Next to all the positives, though, there usually is a downside when using CSS-in-JS: the calculation of styles at runtime can cause a <a href=""https://calendar.perfplanet.com/2019/the-unseen-performance-costs-of-css-in-js-in-react-apps/"">noticeable lag for end users</a>. With <a href=""https://linaria.now.sh/"">Linaria</a> we're now seeing a new class of frameworks that were created with this issue in mind. Linaria employs a number of techniques to shift most of the performance overhead to build time. Alas, this does come with its own set of trade-offs, most notably a lack of dynamic style support in IE11.</p>"
Exposed,Trial,languages-and-frameworks,TRUE,"<p>Through their extended use of <a href=""/radar/languages-and-frameworks/kotlin"">Kotlin</a>, our development teams have gained experience with more frameworks designed specifically for Kotlin rather than using Java frameworks with Kotlin. Although it's been around for a while, <strong><a href=""https://github.com/JetBrains/Exposed"">Exposed</a></strong> has caught our attention as a lightweight object-relational mapper (ORM). Exposed has two flavors of database access: a typesafe internal DSL wrapping SQL and an implementation of the data access object (DAO) pattern. It supports features expected from a mature ORM such as handling of many-to-many references, eager loading, and support for joins across entities. We also like that the implementation works without proxies and doesn't rely on reflection, which is certainly beneficial to performance.</p>"
GraphQL Inspector,Trial,languages-and-frameworks,TRUE,"<p><strong><a href=""https://github.com/kamilkisiela/graphql-inspector"">GraphQL Inspector</a></strong> lets you compare changes between two GraphQL schemas. We've <a href=""/radar/languages-and-frameworks/graphql"">cautioned against the use of GraphQL</a> in the past, and we're happy to see some improvements in tooling around GraphQL since. Most of our teams continue to use <a href=""/radar/techniques/graphql-for-server-side-resource-aggregation"">GraphQL for server-side resource aggregation</a>, and by integrating GraphQL Inspector in their CI pipelines, we've been able to catch potential breaking changes in the GraphQL schema.</p>"
Karate,Trial,languages-and-frameworks,FALSE,"<p>Given our experience that tests are the only API specifications that really matter, we're always on the lookout for new tools that might help with testing. <strong><a href=""https://intuit.github.io/karate/"">Karate</a></strong> is an API testing framework whose unique feature is that tests are written in Gherkin-based syntax without relying on a general-purpose programming language to implement test behavior. Karate uses a domain-specific language for describing HTTP-based API tests. Our teams like the readable specification that they get with this tool and recommend to keep tests with Karate in the upper levels of the <a href=""https://martinfowler.com/articles/practical-test-pyramid.html"">testing pyramid</a> and not overload its use by making very detailed assertions.</p>"
Koin,Trial,languages-and-frameworks,TRUE,"<p>As <a href=""/radar/languages-and-frameworks/kotlin"">Kotlin</a> is used increasingly for both mobile and server-side development, the associated ecosystem continues to evolve. <strong><a href=""https://insert-koin.io/"">Koin</a></strong> is a Kotlin framework that handles one of the routine problems in software development: dependency injection. Although you can choose from a variety of dependency injection frameworks for Kotlin, our teams have come to prefer the simplicity of Koin. Koin avoids using annotations and injects either through constructors or by mimicking Kotlin's lazy initialization so that objects are injected only when needed. This is in contrast to the statically compiled <a href=""/radar/languages-and-frameworks/dagger"">Dagger</a> injection framework for Android. Our developers like the lightweight nature of this framework and its built-in testability.</p>"
NestJS,Trial,languages-and-frameworks,FALSE,"<p>The growth in popularity of Node.js and trends such as <a href=""/radar/platforms/node-overload"">Node overload</a> have led to the application of Node.js for developing business applications. We often see problems, such as scalability and maintainability, with large JavaScript-based applications. <strong><a href=""https://nestjs.com/"">NestJS</a></strong> is a <a href=""/radar/languages-and-frameworks/typescript"">TypeScript-first</a> framework that makes the development of Node.js applications safer and less error prone. NestJS is opinionated and comes with SOLID principles and an Angular-inspired architecture out of the box. When building Node.js microservices, NestJS is one of the frameworks that our teams commonly use to empower developers to create testable, scalable, loosely coupled and easily maintainable applications.</p>"
PyTorch,Trial,languages-and-frameworks,FALSE,"<p>Our teams have continued to use and appreciate the <strong><a href=""http://pytorch.org/"">PyTorch</a></strong> machine learning framework, and several teams prefer PyTorch over <a href=""/radar/languages-and-frameworks/tensorflow"">TensorFlow</a>. PyTorch exposes the inner workings of ML that TensorFlow hides, making it easier to debug, and contains constructs that programmers are familiar with such as loops and actions. Recent releases have improved performance of PyTorch, and we've been using it successfully in production projects.</p>"
Rust,Trial,languages-and-frameworks,FALSE,"<p><strong><a href=""http://www.rust-lang.org/"">Rust</a></strong> is continuously gaining in popularity. We've had heated discussions about which is better, Rust or C++/Go, without a clear winner. However, we're glad to see Rust has improved significantly, with more built-in APIs being added and stabilized, including <a href=""https://blog.rust-lang.org/2019/11/07/Async-await-stable.html"">advanced async support</a>, since we mentioned it in our previous Radar. In addition, Rust has also inspired the design of new languages. For example, the <a href=""https://developers.libra.org/docs/move-overview"">Move language</a> on Libra borrows Rust's way of managing memory to manage resources, ensuring that digital assets can never be copied or implicitly discarded.</p>"
Sarama,Trial,languages-and-frameworks,TRUE,"<p><strong><a href=""https://github.com/Shopify/sarama"">Sarama</a></strong> is a Go client library for <a href=""/radar/tools/apache-kafka"">Apache Kafka</a>. If you’re developing your APIs in Go, you'll find Sarama quite easy to set up and manage as it doesn't depend on any native libraries. Sarama has two types of APIs — a high-level API for easily producing and consuming messages and a low-level API for controlling bytes on the wire.</p>"
SwiftUI,Trial,languages-and-frameworks,FALSE,"<p>Apple has taken a big step forward with their new <strong><a href=""https://developer.apple.com/xcode/swiftui/"">SwiftUI</a></strong> framework for implementing user interfaces on the macOS and iOS platforms. We like that SwiftUI moves beyond the somewhat kludgy relationship between Interface Builder and Xcode and adopts a coherent, declarative and code-centric approach. You can now view your code and the resulting visual interface side by side in Xcode 11, making for a much better developer experience. The SwiftUI framework also draws inspiration from the <a href=""/radar/languages-and-frameworks/react-js"">React.js</a> world that has dominated web development in recent years. Immutable values in view models and an asynchronous update mechanism make for a unified reactive programming model. This gives developers an entirely native alternative to similar reactive frameworks such as <a href=""/radar/languages-and-frameworks/react-native"">React Native</a> or <a href=""/radar/languages-and-frameworks/flutter"">Flutter</a>. SwiftUI definitely represents the future of Apple UI development, and although new, it has shown its benefits. We've been having great experience with it — and its shallow learning curve. It's worth noting that you should know your customer's use case before jumping into using SwiftUI, given that it doesn't support iOS 12 or below.</p>"
Clinic.js Bubbleprof,Assess,languages-and-frameworks,TRUE,"<p>With the aim of improving performance in our code, profiling tools are very useful to identify bottlenecks or delays in code which are hard to identify, especially in asynchronous operations. <strong><a href=""https://clinicjs.org/bubbleprof/"">Clinic.js Bubbleprof</a></strong> represents visually the async operations in Node.js processes, drawing a map of delays in the application's flow. We like this tool because it helps developers to easily identify and prioritize what to improve in the code.</p>"
Deequ,Assess,languages-and-frameworks,TRUE,"<p>There are still some tool gaps when applying good software engineering practices in data engineering. Attempting to automate data quality checks between different steps in a data pipeline, one of our teams was surprised when they found only a few tools in this space. They settled on <strong><a href=""https://github.com/awslabs/deequ"">Deequ</a></strong>, a library for writing tests that resemble unit tests for data sets. Deequ is built on top of <a href=""/radar/platforms/apache-spark"">Apache Spark</a>, and even though it's published by AWS Labs it can be used in environments other than <a href=""/radar/platforms/aws"">AWS</a>.</p>"
ERNIE,Assess,languages-and-frameworks,TRUE,"<p>In the previous edition of the Radar we had <a href=""/radar/techniques/bert"">BERT</a> — which is a key milestone in the NLP landscape. Last year, Baidu released <strong><a href=""https://github.com/PaddlePaddle/ERNIE/"">ERNIE</a></strong> 2.0 (Enhanced Representation through kNowledge IntEgration) which outperformed BERT on seven GLUE language understanding tasks and on all nine of the Chinese NLP tasks. ERNIE, like BERT, provides unsupervised pretrained language models, which can be fine-tuned by adding output layers to create state-of-the-art models for a variety of NLP tasks. ERNIE differs from traditional pretraining methods in that it is a continual pretraining framework. Instead of training with a small number of pretraining objectives, it could constantly introduce a large variety of pretraining tasks to help the model efficiently learn language representations. We're pretty excited about the advancements in NLP and are looking forward to experimenting with ERNIE on our projects.</p>"
MediaPipe,Assess,languages-and-frameworks,TRUE,"<p><strong><a href=""https://github.com/google/mediapipe"">MediaPipe</a></strong> is a framework for building MultiModal (such as video, audio, time series data, etc.), cross-platform (for example, Android, iOS, Web, and edge devices) and applied ML pipelines. It provides multiple capabilities, including face detection, hand tracking, gesture detection and object detection. Although MediaPipe is primarily deployed to mobile devices, it's started to show up in the browser thanks to WebAssembly and XNNPack ML Inference Library. We're exploring MediaPipe for some AR use cases and like what we see so far.</p>"
Tailwind CSS,Assess,languages-and-frameworks,TRUE,"<p>CSS tools and frameworks offer predesigned components for fast results; after a while, however, they can complicate customization. <strong><a href=""https://tailwindcss.com/"">Tailwind CSS</a></strong> proposes an interesting approach by providing lower-level utility CSS classes to create building blocks without opinionated styles and aiming for easy customization. The breadth of the low-level utilities allows you to avoid writing any classes or CSS on your own which leads to a more maintainable codebase in the long term. It seems that Tailwind CSS offers the right balance between reusability and customization to create visual components.</p>"
Tamer,Assess,languages-and-frameworks,TRUE,"<p>If you need to ingest data from relational databases into a Kafka topic, consider <strong><a href=""https://github.com/laserdisc-io/tamer"">Tamer</a></strong>, which labels itself ""a domesticated JDBC source connector for Kafka."" Despite being a relatively new framework, we've found Tamer to be more efficient than the Kafka JDBC connector, especially when huge amounts of data are involved.</p>"
Wire,Assess,languages-and-frameworks,TRUE,"<p>The Golang community has had its fair share of dependency injection skeptics, partly because they confused the <a href=""https://martinfowler.com/articles/injection.html"">pattern</a> with specific frameworks, and developers with a system-programming background naturally dislike runtime overhead caused by reflection. Then along came <strong><a href=""https://github.com/google/wire"">Wire</a></strong>, a compile-time dependency injection tool that can generate code and wire components together. Wire has no additional runtime overhead, and the static dependency graph is easier to reason about. Whether you handwrite your code or use frameworks, we recommend using dependency injection to encourage modular and testable designs.</p>"
XState,Assess,languages-and-frameworks,TRUE,"<p>We've featured several state management libraries in the Radar before, but <strong><a href=""https://xstate.js.org/docs/"">XState</a></strong> takes a slightly different approach. It's a simple JavaScript and <a href=""/radar/languages-and-frameworks/typescript"">TypeScript</a> framework for creating finite state machines and visualizing them as state charts. It integrates with the more popular reactive JavaScript frameworks (<a href=""/radar/languages-and-frameworks/vue-js"">Vue.js</a>, <a href=""/radar/languages-and-frameworks/ember-js"">Ember.js</a>, <a href=""/radar/languages-and-frameworks/react-js"">React.js</a> and <a href=""https://rxjs.dev/"">RxJS</a>) and is based on the W3C standard for finite state machines. Another notable feature is the serialization of machine definitions. One thing that we've found helpful when creating finite state machines in other contexts (particularly when writing game logic) is the ability to visualize states and their possible transitions; we like the fact that it's really easy to do this with XState's <a href=""https://xstate.js.org/viz/"">visualizer</a>.</p>"
Enzyme,Hold,languages-and-frameworks,FALSE,"<p>We don't always move deprecated tools to Hold in the Radar, but our teams feel strongly that <strong><a href=""http://airbnb.io/enzyme/"">Enzyme</a></strong> has been replaced for unit testing <a href=""/radar/languages-and-frameworks/react-js"">React</a> UI components by <a href=""https://testing-library.com/docs/intro"">React Testing Library</a>. Teams using Enzyme have found that its focus on testing component internals leads to brittle, unmaintainable tests.</p>"
